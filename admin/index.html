<!doctype html>
<meta charset="utf-8" />
<title>Irregular selection over fixed PNG</title>
<style>
    :root {
        --overlay: rgba(128, 128, 128, 0.6);
        --border: #333;
        --accent: #56a;
    }

    body {
        background: #0f0f10;
        color: #ddd;
        font: 14px/1.3 system-ui, sans-serif;
        margin: 20px;
    }

    .toolbar {
        margin-bottom: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .toolbar input,
    .toolbar button,
    .toolbar select {
        background: #1a1a1c;
        color: #ddd;
        border: 1px solid #2a2a2d;
        padding: 6px 10px;
    }

    .toolbar input[type="text"] {
        width: 220px;
    }

    .toolbar .hint {
        color: #999;
        margin-left: 8px;
    }

    .stage-wrap {
        position: relative;
        display: inline-block;
    }

    .stage {
        position: relative;
        /* width/height set to image natural size at runtime */
        background: #111;
        user-select: none;
    }

    .stage img#bg {
        display: block;
        width: auto;
        height: auto;
        /* natural size */
        pointer-events: none;
    }

    .cell {
        position: absolute;
        overflow: hidden;
        cursor: pointer;
        outline: 1px solid var(--border);
    }

    .cell img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: grayscale(1);
    }

    .cell::after {
        content: "";
        position: absolute;
        inset: 0;
        background: var(--overlay);
        transition: opacity 120ms ease-in-out;
        pointer-events: none;
        opacity: 1;
    }

    .cell.selected img {
        filter: grayscale(0);
    }

    .cell.selected::after {
        opacity: 0;
    }

    .cell .tag {
        position: absolute;
        left: 4px;
        bottom: 4px;
        background: rgba(0, 0, 0, 0.5);
        color: #eee;
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 3px;
    }

    /* edit mode visuals */
    .stage.edit .cell {
        outline: 1px dashed var(--accent);
    }

    .stage.edit .rubber {
        position: absolute;
        border: 1px dashed var(--accent);
        background: rgba(86, 106, 170, 0.15);
        pointer-events: none;
    }

    textarea#json {
        width: 100%;
        max-width: 900px;
        height: 140px;
        background: #111;
        color: #ddd;
        border: 1px solid #2a2a2d;
        padding: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12px;
    }
</style>

<div class="toolbar">
    <label>Background PNG:
        <input id="bgPath" type="text" value="bg.png" />
    </label>
    <button id="loadBg">Load</button>
    <label><input id="editMode" type="checkbox" /> Edit mode</label>
    <label>Default slot: <input id="defSlot" type="text" value="slot" /></label>
    <label>Default value: <input id="defValue" type="text" value="0" /></label>
    <button id="export">Export JSON</button>
    <button id="clearSel">Clear selection</button>
    <span class="hint">Drag to draw in Edit mode. Click cells to toggle uncover. Right-click cell to delete (Edit
        only).</span>
</div>

<div class="stage-wrap">
    <div id="stage" class="stage">
        <img id="bg" src="" alt="">
    </div>
</div>

<p><strong>Layout JSON</strong> (paste here and click “Import JSON”):</p>
<textarea id="json"
    placeholder='[{"id":"A1","p1":{"x":20,"y":20},"p2":{"x":200,"y":140},"img":"img/a.jpg","slot":"top-left","value":10}]'></textarea>
<div class="toolbar">
    <button id="import">Import JSON</button>
</div>

<script>
    (() => {
        const stage = document.getElementById('stage');
        const bg = document.getElementById('bg');
        const bgPathInput = document.getElementById('bgPath');
        const editToggle = document.getElementById('editMode');
        const defSlot = document.getElementById('defSlot');
        const defValue = document.getElementById('defValue');
        const jsonTA = document.getElementById('json');

        const items = []; // runtime list
        const state = new Map(); // id -> {selected:boolean, meta:item}

        let idSeq = 1;
        function nextId() { return 'R' + (idSeq++).toString().padStart(3, '0'); }

        // Load background and size the stage to natural pixels
        document.getElementById('loadBg').addEventListener('click', () => {
            const src = bgPathInput.value.trim();
            if (!src) return;
            bg.onload = () => {
                // lock stage to image natural size
                stage.style.width = bg.naturalWidth + 'px';
                stage.style.height = bg.naturalHeight + 'px';
            };
            bg.src = src;
            bg.alt = src;
        });

        // Export / Import
        document.getElementById('export').addEventListener('click', () => {
            const data = items.map(it => ({
                id: it.id, p1: it.p1, p2: it.p2, img: it.img,
                slot: it.slot, value: it.value
            }));
            jsonTA.value = JSON.stringify(data, null, 2);
        });

        document.getElementById('import').addEventListener('click', () => {
            try {
                const arr = JSON.parse(jsonTA.value);
                clearCells();
                arr.forEach(addItem);
            } catch (e) {
                alert('Bad JSON');
            }
        });

        document.getElementById('clearSel').addEventListener('click', () => {
            stage.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));
            for (const [id, obj] of state) state.set(id, { ...obj, selected: false });
        });

        editToggle.addEventListener('change', () => {
            stage.classList.toggle('edit', editToggle.checked);
        });

        function rectFromDiagonal(p1, p2) {
            const left = Math.min(p1.x, p2.x);
            const top = Math.min(p1.y, p2.y);
            const width = Math.abs(p2.x - p1.x);
            const height = Math.abs(p2.y - p1.y);
            return { left, top, width, height };
        }

        function addItem(it) {
            // fill defaults
            if (!it.id) it.id = nextId();
            if (!it.slot) it.slot = defSlot.value || 'slot';
            if (typeof it.value === 'undefined') it.value = defValue.value || 0;

            items.push(it);

            const { left, top, width, height } = rectFromDiagonal(it.p1, it.p2);
            const cell = document.createElement('div');
            cell.className = 'cell';
            Object.assign(cell.style, {
                left: left + 'px', top: top + 'px',
                width: width + 'px', height: height + 'px'
            });
            cell.dataset.id = it.id;

            // optional per-cell image (if you want unique art per region).
            // If you just want the PNG background, comment the image out.
            if (it.img) {
                const img = document.createElement('img');
                img.src = it.img; img.alt = it.id;
                cell.appendChild(img);
            }

            const tag = document.createElement('div');
            tag.className = 'tag';
            tag.textContent = `${it.id} • ${it.slot} • ${it.value}`;
            cell.appendChild(tag);

            // click to toggle uncover
            cell.addEventListener('click', (ev) => {
                if (editToggle.checked) return; // ignore in edit mode
                ev.stopPropagation();
                cell.classList.toggle('selected');
                const sel = cell.classList.contains('selected');
                state.set(it.id, { selected: sel, meta: it });
            });

            // right-click delete (edit mode only)
            cell.addEventListener('contextmenu', (ev) => {
                if (!editToggle.checked) return;
                ev.preventDefault();
                const idx = items.findIndex(x => x.id === it.id);
                if (idx >= 0) items.splice(idx, 1);
                state.delete(it.id);
                cell.remove();
            });

            stage.appendChild(cell);
            state.set(it.id, { selected: false, meta: it });
        }

        function clearCells() {
            items.splice(0, items.length);
            state.clear();
            stage.querySelectorAll('.cell').forEach(el => el.remove());
        }

        // Edit mode: drag to draw rectangles
        let dragStart = null;
        let rubber = null;

        stage.addEventListener('mousedown', (ev) => {
            if (!editToggle.checked) return;
            if (ev.button !== 0) return; // left only
            const pt = stageCoords(ev);
            dragStart = pt;
            rubber = document.createElement('div');
            rubber.className = 'rubber';
            stage.appendChild(rubber);
            updateRubber(pt, pt);
        });

        stage.addEventListener('mousemove', (ev) => {
            if (!editToggle.checked || !dragStart || !rubber) return;
            updateRubber(dragStart, stageCoords(ev));
        });

        stage.addEventListener('mouseup', (ev) => {
            if (!editToggle.checked || !dragStart || !rubber) return;
            const p1 = dragStart, p2 = stageCoords(ev);
            const { width, height } = rectFromDiagonal(p1, p2);
            rubber.remove(); rubber = null; dragStart = null;
            if (width < 2 || height < 2) return; // ignore tiny drags

            // Create an item with defaults; you can edit later via JSON
            addItem({
                id: nextId(),
                p1, p2,
                img: "",               // leave empty to show just background
                slot: defSlot.value || 'slot',
                value: defValue.value || 0
            });
        });

        // helper: mouse -> stage pixel coords
        function stageCoords(ev) {
            const r = stage.getBoundingClientRect();
            const x = Math.max(0, Math.min(ev.clientX - r.left, r.width));
            const y = Math.max(0, Math.min(ev.clientY - r.top, r.height));
            // r.width/height equals CSS pixels; stage is locked to image pixels, so 1:1.
            return { x: Math.round(x), y: Math.round(y) };
        }

        function updateRubber(a, b) {
            const { left, top, width, height } = rectFromDiagonal(a, b);
            Object.assign(rubber.style, {
                left: left + 'px', top: top + 'px', width: width + 'px', height: height + 'px'
            });
        }

        // Autoload default background on first run
        document.getElementById('loadBg').click();

        // Expose selection getter for debugging
        window.getSelected = () => [...state.values()].filter(v => v.selected).map(v => v.meta);
    })();
</script>